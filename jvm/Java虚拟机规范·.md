​                          参考《Java虚拟机规范（第7版）》的描述，JVM包含三种引用类型，分别是类型 (class type)，数组类型(array type)和接口类型(interface type)，这些引用类型的值则分别 由类实例、数组实例以及实现了某个接口的派生类实例负责动态创建，那么JVM中究 竟是如何为这些类型创建对应的对象实例呢？-------------如果是在Java语法层面上创建 一个对象，无非就是使用一个简单的new关键字即可，但是在JVM中就没有那么简 单了，其实牵扯到细节的实现相当复杂，而且过程繁多。简单地说，当Java语法层面 使用new关键字创建一个Java对象时，JVM首先会检查这个new指令的参数能否在常 量池中定位到一个类的符号引用，然后检查与这个符号引用相对应的类是否已经成功经 历加载、解析和初始化等步骤，当类完成装载步骤之后，就已经完全确定出创建对象实 例时所需的内存空间大小，接下来JVM将会对其进行内存分配，以存储所生成的对象 实例。如下图所示：

​                                  为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还要考虑GC执行完内存回收后是否会在内存空间中产生内部碎片。如果内存空间以规整和有序的的方式分布，当为新对象分配内存时，只需要修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump the Pointer）,反之则只能使用空闲列表（Free List）执行内存分配。

基于分代的概念，Java堆区如果进一步细分的话，还可分为：新生代 ( Young )和老年代 ( Old )；这也就是JVM采用的“分代思想”，简单说，就是针对不同特征的java对象采用不同的策略实施存放和回收，所用分配机制和回收算法就不一样。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。（《Java虚拟机精讲》）

分代收集算法：采用不同算法处理[存放和回收]Java瞬时对象和长久对象。大部分Java对象都是瞬时对象，朝生夕灭，存活很短暂，通常存放在Young新生代，采用复制算法对新生代进行垃圾回收。老年代对象的生命周期一般都比较长，极端情况下会和JVM生命周期保持一致；通常采用标记-压缩算法对老年代进行垃圾回收。

这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。那么Java堆区被细分成这么多区域，对象实例究竟是存储在堆区中的那一个区域下呢？在JVM运行数据区中，堆区和方法区是线程共享的数据区，任何线程都可以访问到这两个区域中的共享数据，由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆中划分内存空间是非线程安全的，所以务必需要保证数据操作的原子性。基于线程安全的考虑，如果一个类在分配内存之前成功完成的类加载，JVM会优先选择在TLAB（Thread Local Allocation Buffer，本地线程分配缓存区）中为对象实例分配内存空间，TLAB在Java堆中是一块线程私有数据区，它包含在Eden空间内，除了可以避免一系列的非线程安全问题外，同时还能提高内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。

当为对象成功分配好所需的内存空间（实例化）后，JVM接下来要做的任务就是-------初始化对象实例。JVM首先会对分配好的内存空间进行零值初始化，这一步操作确保了对象的实例字段在Java代码中可以不用赋初值就能够直接使用，程序能够访问到这些字段的数据类型所对应的零值。

对分配后的内存空间进行零值初始化后，JVM就会初始化对象头和实例数据。最后将对象引入栈后，再更新PC寄存器中的字节码指令地址。经过这一系列的操作步骤之后每一个Java对象实例才算是真正的创建成功。

#### 总结

1.在Java语法层面上创建一个对象，使用一个简单的new关键字即可，但是在JVM中细节的实现相当复杂，而且过程繁多。

2.当Java语法层面使用new关键字创建一个Java对象时，JVM首先会检查相对应的类是否已经成功经历加载、解析和初始化等步骤；当类完成装载步骤之后，就已经完全确定出创建对象实例时所需的内存空间大小，才能对其进行内存分配，以存储所生成的对象实例。

3.实例化之后，进行初始化（初始化对象头和实例数据）。

4.内存分配方式有：指针碰撞（Bump the Pointer）、快速分配策略、空闲列表（Free List）。

5.在并发环境下从堆中划分内存空间是非线程安全的，new运算符具有-------数据操作的原子性；也就是说创建一个Java对象分配内存，要么所有步骤都成功，返回对象的引用，要么回归到创建之前的内存状态，返回为NULL。

6.通过new创建一个Java对象，如果成功则返回这个对象的引用，开发者不可直接操作对象实例，需要通过这个引用“牵引”。

看完这篇文章，相信你对Java关键字new及Java对象的完整创建过程有了更深的认识，就不会只停留在new一个对象就完了。