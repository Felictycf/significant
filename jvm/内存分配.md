1.在new 对象的时候，jvm会使用在堆空间里面开辟空间（也可能在栈上分配，存在逃逸分析和标量替换的技术，让对象变成聚合量的方式，变成成员变量），之后在栈里面去引用；

#### 2方法变量的引用.

1. 调用change(int i)
此时在栈空间中新建了一个i，并把data的值复制给i。这个时候在栈空间中有两个int类型的数，二者的值虽然都为10，但是二者毫无关系，栈空间中有两个10.
在方法体中对i进行赋值，该操作是对i进行的，并不影响data，所以当方法结束时data还是原来的data，连地址都没变一下。同时在方法结束时i自动从栈空间中消失。
2. 验证不开启逃逸分析和变量替换将会产生大量GC（采用控制变量法进行测试）

#### 3.内存对象的内存分配

栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。

Java的堆是一个运行时数据区,类的对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，因此,用堆保存数据时会得到更大的灵活性。变量所需的存储空间只有在运行时创建了对象之后才能确定。Java的垃圾收集器会自动收走这些不再使用的数

据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。

栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量(,int, short, long, byte, float, double, boolean, char)和引用对象,**栈里存的却是堆的首地址名；就像引用变量**。

```java
例子：

String s=new String("123");

这个s就在栈里面，而他的"123"这个对象在堆里面。 s 指向"123";
```

现在程序开始运行了，你在程序里面，有很多的局部变量，你调用一个方法一次，JVM给栈里面写一个记录，这个记录叫做栈帧方法调用完成，栈帧消亡，被JVM清除，引用类型的变量是存放在栈里面的Point p = new Point() p是存放在栈中的。

然后堆中存放的是对象，就是你new出来的对象

